
{# ========================================================================== #}
{# :: Variables #}
{# ========================================================================== #}
{% set subtitle = data.commonSubtitle ?? "" %}
{% set title = data.commonTitle ?? "" %}
{% set description = data.commonDescription ?? "" %}
{% set link = data.commonLink ?? null %}

{# ========================================================================== #}
{# :: Component #}
{# ========================================================================== #}
<section class="px-4 lg:px-8 text-white bg-cover bg-center bg-no-repeat relative" style="background-image: url('/assets/gradient.png');">
    {# Animated logo grid with supply-chain transport animation #}
    <div
        x-data="{
            segments: [],
            segId: 0,
            segOpacity: 1,
            activeLogos: [],
            cols: 0,
            logoArray: [],
            lineGeom(from, to) {
                const c = this.$el.getBoundingClientRect();
                const f = from.getBoundingClientRect();
                const t = to.getBoundingClientRect();
                const fx = f.left + f.width/2 - c.left, fy = f.top + f.height/2 - c.top;
                const tx = t.left + t.width/2 - c.left, ty = t.top + t.height/2 - c.top;
                return {
                    x: fx, y: fy,
                    len: Math.sqrt((tx-fx)**2+(ty-fy)**2).toFixed(1),
                    angle: (Math.atan2(ty-fy, tx-fx)*180/Math.PI).toFixed(2)
                };
            },
            buildPath(a, b, all) {
                const cols = this.cols;
                const aRow = Math.floor(a/cols), aCol = a%cols;
                const bRow = Math.floor(b/cols), bCol = b%cols;
                const dr = bRow >= aRow ? 1 : -1, dc = bCol >= aCol ? 1 : -1;
                const path = [a];
                if (Math.random() < 0.5) {
                    for (let col=aCol+dc; col*dc<=bCol*dc; col+=dc) { const i=aRow*cols+col; if(i>=0&&i<all.length) path.push(i); }
                    for (let row=aRow+dr; row*dr<=bRow*dr; row+=dr) { const i=row*cols+bCol; if(i>=0&&i<all.length) path.push(i); }
                } else {
                    for (let row=aRow+dr; row*dr<=bRow*dr; row+=dr) { const i=row*cols+aCol; if(i>=0&&i<all.length) path.push(i); }
                    for (let col=aCol+dc; col*dc<=bCol*dc; col+=dc) { const i=bRow*cols+col; if(i>=0&&i<all.length) path.push(i); }
                }
                if (path[path.length-1] !== b) path.push(b);
                return path.map(i => all[i]).filter(Boolean);
            },
            async _doJourney() {
                this.activeLogos.forEach(el => el.classList.remove('hero-logo-active','hero-logo-transit','hero-logo-visited'));
                this.activeLogos = [];
                this.segments = [];
                this.segOpacity = 1;
                const all = this.$el.querySelectorAll('.hero-logo');
                if (!all.length) return;
                let a, b, attempts = 0;
                do {
                    a = Math.floor(Math.random()*all.length);
                    b = Math.floor(Math.random()*all.length);
                    const dist = Math.abs(Math.floor(a/this.cols)-Math.floor(b/this.cols))
                               + Math.abs((a%this.cols)-(b%this.cols));
                    if (dist>=8 && dist<=18) break;
                } while (++attempts < 200);
                const path = this.buildPath(a, b, all);
                if (path.length < 2) { await new Promise(r=>setTimeout(r,1000)); return; }
                this.activeLogos = path;
                path[0].classList.add('hero-logo-active');
                path[path.length-1].classList.add('hero-logo-active');
                await new Promise(r => setTimeout(r, 500));
                for (let i = 0; i < path.length-1; i++) {
                    const isLastHop = i === path.length-2;
                    if (!isLastHop) path[i+1].classList.add('hero-logo-transit');
                    const geom = this.lineGeom(path[i], path[i+1]);
                    this.segments.push({...geom, id: ++this.segId});
                    await new Promise(r => setTimeout(r, 380));
                    if (i > 0) { path[i].classList.remove('hero-logo-active','hero-logo-transit'); path[i].classList.add('hero-logo-visited'); }
                    if (!isLastHop) {
                        path[i+1].classList.remove('hero-logo-transit');
                        path[i+1].classList.add('hero-logo-active');
                    }
                }
                await new Promise(r => setTimeout(r, 1500));
                this.segOpacity = 0;
                path.forEach(el => el.classList.remove('hero-logo-active','hero-logo-visited'));
                await new Promise(r => setTimeout(r, 1000));
                this.segments = [];
                this.segOpacity = 1;
                await new Promise(r => setTimeout(r, 400));
            },
            init() {
                this.$nextTick(async () => {
                    const rect = this.$el.getBoundingClientRect();
                    const cell = 40;  // w-2 (8px) + gap-8 (32px)
                    const pad  = 48;  // p-6 (24px) each side
                    const cols = Math.floor((rect.width  - pad + 32) / cell);
                    const rows = Math.ceil( (rect.height - pad + 32) / cell) + 1;
                    this.cols = cols;
                    this.logoArray = Array.from({length: cols * rows}, (_, i) => i);
                    await new Promise(r => setTimeout(r, 1000));
                    while (true) { await this._doJourney(); }
                });
            }
        }"
        class="absolute inset-0 overflow-hidden pointer-events-none"
    >
        {# Logo grid — count computed from actual section dimensions in init() #}
        <div class="absolute inset-0 flex flex-wrap content-start gap-8 p-6">
            <template x-for="i in logoArray" :key="i">
                <div class="hero-logo w-2 h-2 shrink-0">
                    <svg class="w-full h-full" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 98 99" fill="none">
                        <path d="M68.2923 0.0463867C62.8741 0.0463867 57.8018 1.5018 53.4326 4.03146C62.3092 9.17162 68.2923 18.7704 68.2923 29.7669C68.2923 40.7634 62.3092 50.3622 53.4326 55.5024C57.8018 58.0321 62.8741 59.4875 68.2923 59.4875C84.6967 59.4875 98.0001 46.1808 98.0001 29.7669C98.0001 13.3531 84.6967 0.0463867 68.2923 0.0463867Z" fill="#288760"/>
                        <path d="M29.742 38.7302C35.1602 38.7302 40.2325 40.1856 44.6016 42.7153C35.725 47.8555 29.742 57.4543 29.742 68.4508C29.742 79.4473 35.725 89.0461 44.6016 94.1862C40.2325 96.7159 35.1602 98.1713 29.742 98.1713C13.3376 98.1829 0.0341797 84.8646 0.0341797 68.4508C0.0341797 52.0369 13.3376 38.7302 29.742 38.7302Z" fill="#288760"/>
                        <path d="M97.9997 68.4508C97.9997 63.0334 96.5472 57.9625 94.011 53.5847C88.8695 62.4674 79.2781 68.4508 68.2804 68.4508C57.2826 68.4508 47.6913 62.4674 42.5497 53.5847C40.0251 57.9625 38.561 63.0334 38.561 68.4508C38.561 84.8646 51.8644 98.1713 68.2688 98.1713C84.6733 98.1713 97.9766 84.8646 97.9766 68.4508H97.9997Z" fill="#288760"/>
                        <path d="M59.4387 29.7205C59.4387 35.1379 57.9861 40.2088 55.4499 44.5866C50.3084 35.7039 40.7171 29.7205 29.7193 29.7205C18.7216 29.7205 9.13022 35.7039 3.98871 44.5866C1.46406 40.2088 0 35.1379 0 29.7205C0.0115281 13.3067 13.3149 0 29.7193 0C46.1238 0 59.4271 13.3067 59.4271 29.7205H59.4387Z" fill="#288760"/>
                    </svg>
                </div>
            </template>
        </div>

        {# Accumulated route segments — fade as a group via segOpacity wrapper #}
        <div :style="`opacity: ${segOpacity}; transition: opacity 1s ease;`" class="absolute inset-0 pointer-events-none">
            <template x-for="seg in segments" :key="seg.id">
                <div
                    class="hero-connection-seg absolute pointer-events-none"
                    :style="`left:${seg.x}px; top:${seg.y}px; width:${seg.len}px; transform:rotate(${seg.angle}deg);`"
                ></div>
            </template>
        </div>
    </div>

    <style>
        .hero-logo { opacity: 0.4; transition: opacity 0.6s ease, transform 0.6s ease, filter 0.6s ease; }
        .hero-logo-active { opacity: 0.8; transform: scale(1.3); filter: brightness(0) invert(1); }
        .hero-logo-transit { opacity: 0.6; transform: scale(1.3); filter: brightness(0) invert(1); }
        .hero-logo-visited { opacity: 0.5; filter: brightness(0) invert(1); }
        .hero-connection-seg { height: 2px; transform-origin: 0 50%; background: repeating-linear-gradient(90deg, rgba(255,255,255,0.5) 0, rgba(255,255,255,0.5) 6px, transparent 6px, transparent 10px); }
    </style>

    <div class="container mx-auto py-24 md:py-56 relative">
        <div class="max-w-4xl mx-auto text-center space-y-10">
            {% if subtitle %}
                <span class="s-hero-pill inline-block px-6 py-2 rounded-full text-white text-sm animate-fade-up">
                    {{ subtitle }}
                </span>
            {% endif %}

            {% if title %}
                <h1 class="text-white [&_strong]:text-peach animate-fade-up [animation-delay:100ms]">{{ title|striptags('<strong><br>')|raw }}</h1>
            {% endif %}

            {% if description %}
                <p class="text-white max-w-3xl mx-auto [&_strong]:text-peach text-xl font-normal leading-[1.7] animate-fade-up [animation-delay:200ms]">{{ description|striptags('<strong><br><br/>')|raw }}</p>
            {% endif %}

            {% if link %}
                <div class="animate-fade-up [animation-delay:300ms]">
                    {% include 'components/button' with {
                        href: link.url ?? '#',
                        text: link.text ?? 'Learn More',
                        variant: 'secondary',
                    } %}
                </div>
            {% endif %}
        </div>
    </div>
</section>
